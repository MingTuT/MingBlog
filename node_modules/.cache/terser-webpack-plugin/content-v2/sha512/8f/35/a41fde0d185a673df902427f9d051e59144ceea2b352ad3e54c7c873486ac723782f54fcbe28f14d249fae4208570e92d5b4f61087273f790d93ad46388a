{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{367:function(t,e,v){t.exports=v.p+\"assets/img/getpost.20cc5f5f.png\"},368:function(t,e,v){t.exports=v.p+\"assets/img/eventflow.e578173e.png\"},383:function(t,e,v){\"use strict\";v.r(e);var _=v(44),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[_(\"h1\",{attrs:{id:\"问题\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#问题\"}},[t._v(\"#\")]),t._v(\" 问题\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"get请求和post请求的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#get请求和post请求的区别\"}},[t._v(\"#\")]),t._v(\" GET请求和POST请求的区别\")]),t._v(\" \"),_(\"ol\",[_(\"li\",[t._v(\"请求长度的限制\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"GET请求：浏览器或WEB服务器会对 url 的长度进行限制。\")]),t._v(\" \"),_(\"li\",[t._v(\"POST请求：由于没有 url 传值，理论上是不会受到限制的，但是实际上各个服务器会对 POST 提交的数据大小进行限制。\")])]),t._v(\" \"),_(\"ol\",{attrs:{start:\"2\"}},[_(\"li\",[t._v(\"安全性的区别\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"GET请求：进行登录操作时，会将用户名与密码暴露在 url 上，信息容易被获取。除此之外，GET请求提交的数据还可能会造成CSRF攻击。\")]),t._v(\" \"),_(\"li\",[t._v(\"POST请求：数据通过Request Body传递，不会出现在 url 上。\")])]),t._v(\" \"),_(\"ol\",{attrs:{start:\"3\"}},[_(\"li\",[t._v(\"缓存方面的区别\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"GET请求：类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。\")]),t._v(\" \"),_(\"li\",[t._v(\"POST请求：一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。\")])]),t._v(\" \"),_(\"ol\",{attrs:{start:\"4\"}},[_(\"li\",[t._v(\"获取数据的区别\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"GET请求：从服务器上获取数据，服务器用Request.QueryString获取变量的值。\")]),t._v(\" \"),_(\"li\",[t._v(\"POST请求：向服务器传送数据，服务器用Request.Form获取提交的数据。\")])]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:v(367),alt:\"getpost\"}}),t._v(\" \"),_(\"a\",{attrs:{href:\"https://www.cnblogs.com/princess-knight/p/9293332.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"参考\"),_(\"OutboundLink\")],1)]),t._v(\" \"),_(\"h3\",{attrs:{id:\"get-请求传参长度的误区\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#get-请求传参长度的误区\"}},[t._v(\"#\")]),t._v(\" get 请求传参长度的误区\")]),t._v(\" \"),_(\"p\",[t._v(\"HTTP 协议 未规定 GET 和 POST 的长度限制，\"),_(\"br\"),t._v(\"\\nGET 的最大长度显示是因为 浏览器和 WEB 服务器限制了 URL 的长度，\"),_(\"br\"),t._v(\"\\n不同的浏览器和 WEB 服务器，限制的最大长度不一样。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"一句话粗略概括闭包\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一句话粗略概括闭包\"}},[t._v(\"#\")]),t._v(\" 一句话粗略概括闭包\")]),t._v(\" \"),_(\"p\",[t._v(\"闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"前端中的事件流\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前端中的事件流\"}},[t._v(\"#\")]),t._v(\" 前端中的事件流\")]),t._v(\" \"),_(\"p\",[t._v(\"事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"事件捕获阶段\")]),t._v(\" \"),_(\"li\",[t._v(\"处于目标阶段\")]),t._v(\" \"),_(\"li\",[t._v(\"事件冒泡阶段\"),_(\"br\"),t._v(\" \"),_(\"img\",{attrs:{src:v(368),alt:\"eventflow\"}}),t._v(\"\\nHTML 中与 javascript 交互是通过事件驱动来实现的，可以向文档或者文档中的元素添加事件侦听器来预订事件。\")])]),t._v(\" \"),_(\"h2\",{attrs:{id:\"如何让事件先冒泡后捕获\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何让事件先冒泡后捕获\"}},[t._v(\"#\")]),t._v(\" 如何让事件先冒泡后捕获\")]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"在 DOM 标准事件模型中，是\"),_(\"font\",{attrs:{color:\"red\"}},[t._v(\"先捕获后冒泡\")])],1),t._v(\"。\"),_(\"br\"),t._v(\"\\n但是如果要\"),_(\"strong\",[t._v(\"实现先冒泡后捕获的效果\")]),t._v(\"，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"事件委托\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事件委托\"}},[t._v(\"#\")]),t._v(\" 事件委托\")]),t._v(\" \"),_(\"p\",[t._v(\"事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，\"),_(\"br\"),t._v(\"\\n通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"图片的懒加载和预加载\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#图片的懒加载和预加载\"}},[t._v(\"#\")]),t._v(\" 图片的懒加载和预加载\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。\")]),t._v(\" \"),_(\"li\",[t._v(\"懒加载：延缓或不加载，懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。\")])]),t._v(\" \"),_(\"p\",[t._v(\"懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"mouseover-和-mouseenter-的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mouseover-和-mouseenter-的区别\"}},[t._v(\"#\")]),t._v(\" mouseover 和 mouseenter 的区别\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"mouseover(鼠标覆盖)\"),_(\"br\"),t._v(\"\\nmouseover 会被它的子元素影响到,在触发子元素的时候,mouseover 会冒泡触发它的父元素\")]),t._v(\" \"),_(\"li\",[t._v(\"mouseenter(鼠标进入)\"),_(\"br\"),t._v(\"\\nmouseenter 不会冒泡,简单的说,它不会被它本身的子元素的状态影响到\")])]),t._v(\" \"),_(\"p\",[t._v(\"当二者都没有子元素时,二者的行为是一致的,但是二者内部都包含子元素时,行为就不同了\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"js-的-new-操作符做了哪些事情\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-的-new-操作符做了哪些事情\"}},[t._v(\"#\")]),t._v(\" JS 的 new 操作符做了哪些事情\")]),t._v(\" \"),_(\"p\",[t._v(\"(1) 创建一个新对象；\"),_(\"br\"),t._v(\"\\n(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；\"),_(\"br\"),t._v(\"\\n(3) 执行构造函数中的代码（为这个新对象添加属性）；\"),_(\"br\"),t._v(\"\\n(4) 返回新对象。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"js-的各种位置\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-的各种位置\"}},[t._v(\"#\")]),t._v(\" JS 的各种位置\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[t._v(\"元素\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"offsetLeft （距离定位父级的距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"offsetTop （距离定位父级的距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"offsetWidth （可视宽度）\")]),t._v(\" \"),_(\"li\",[t._v(\"offsetHeight （可视高度 包含了 border 和滚动条）\")]),t._v(\" \"),_(\"li\",[t._v(\"clientLeft （左边框宽度）\")]),t._v(\" \"),_(\"li\",[t._v(\"clientTop （上边框宽度）\")]),t._v(\" \"),_(\"li\",[t._v(\"clientWidth（width + padding）\")]),t._v(\" \"),_(\"li\",[t._v(\"clientHeight（height + padding 不包含 border 和滚动条）\")]),t._v(\" \"),_(\"li\",[t._v(\"scrollTop（纵向滚动距离 滚动后被隐藏的高度）\")]),t._v(\" \"),_(\"li\",[t._v(\"scrollLeft（横向滚动距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"scrollWidth（内容宽度）\")]),t._v(\" \"),_(\"li\",[t._v(\"scrollHeight（内容高度 包含了因为滚动被隐藏的部分）\")])])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"getBoundingClientRect ( ) 返回值\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"left（元素左侧相对于可视区左上角的距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"right（元素右侧相对于可视区左上角的距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"top（元素上边相对于可视区左上角的距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"bottom（元素下边相对于可视区左上角的距离）\")]),t._v(\" \"),_(\"li\",[t._v(\"width（可视宽度）\")]),t._v(\" \"),_(\"li\",[t._v(\"height（可视高度）\")])])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"获取可视区宽高\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"window.innerWidth\")]),t._v(\" \"),_(\"li\",[t._v(\"window.innerHeight\")]),t._v(\" \"),_(\"li\",[t._v(\"document.documentElement.clientWidth\")]),t._v(\" \"),_(\"li\",[t._v(\"document.documentElement.clientHeight\")])])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"获取文档宽高\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"document.body.clientWidth\")]),t._v(\" \"),_(\"li\",[t._v(\"document.body.clientHeight\")]),t._v(\" \"),_(\"li\",[t._v(\"document.documentElement.scrollWidth\")]),t._v(\" \"),_(\"li\",[t._v(\"document.documentElement.scrollHeight\")]),t._v(\" \"),_(\"li\",[t._v(\"document.body.scrollWidth（如果内容宽度超过一屏，得到文档宽度；如果内容小于一屏，得到一屏的宽度）\")]),t._v(\" \"),_(\"li\",[t._v(\"document.body.scrollHeight （如果内容高度超过一屏，得到文档高度；如果内容小于一屏，得到一屏的高度）\")])])]),t._v(\" \"),_(\"li\",[_(\"strong\",[t._v(\"获取滚动条距离\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"document.body.scrollTop\")]),t._v(\" \"),_(\"li\",[t._v(\"document.body.scrollLeft\")]),t._v(\" \"),_(\"li\",[t._v(\"window.scrollY\")]),t._v(\" \"),_(\"li\",[t._v(\"window.scrollX\")]),t._v(\" \"),_(\"li\",[t._v(\"document.documentElement.scrollTop\")]),t._v(\" \"),_(\"li\",[t._v(\"document.documentElement.scrollLeft\")]),t._v(\" \"),_(\"li\",[t._v(\"window.pageYOffset\")]),t._v(\" \"),_(\"li\",[t._v(\"window.pageXOffset\")])])])]),t._v(\" \"),_(\"h2\",{attrs:{id:\"ajax-解决浏览器缓存问题\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ajax-解决浏览器缓存问题\"}},[t._v(\"#\")]),t._v(\" Ajax 解决浏览器缓存问题\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"浏览器缓存原因\"),_(\"br\"),t._v(\"\\najax能提高页面载入的速度主要的原因是ajax能实现局部刷新，通过局部刷新机制减少了重复数据的载入，也就是说在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要没有刷新页面，这些数据就会一直被缓存在内存中，当我们提交 的URL与历史的URL一致时，就不需要提交给服务器，也就是不需要从服务器上面去获取数据。那么，我们得到还是最开始缓存在浏览器中的数据。虽然降低了服务器的负载提高了用户的体验，但是我们不能获取最新的数据。为了保证我们读取的信息都是最新的，我们就需要禁止他的缓存功能。\")]),t._v(\" \"),_(\"li\",[t._v(\"解决方法\"),_(\"br\"),t._v('\\n（1）在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified-Since\",\"0\")。'),_(\"br\"),t._v(\"\\n原理：If-Modified-Since:0 故意让缓存过期\"),_(\"br\"),t._v('\\n（2）在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no-cache\")。'),_(\"br\"),t._v(\"\\n原理：直接禁用缓存机制\"),_(\"br\"),t._v('\\n（3）在URL后面加上一个随机数： \"fresh=\" + Math.random();。'),_(\"br\"),t._v(\"\\n原理：强行让每次的请求地址不同\"),_(\"br\"),t._v('\\n（4）在URL后面加上时间搓：\"nowtime=\" + new Date().getTime();。'),_(\"br\"),t._v(\"\\n原理：强行让每次的请求地址不同\"),_(\"br\"),t._v(\"\\n（5）如果是使用jQuery，直接这样就可以了$.ajaxSetup({cache:false})。\"),_(\"br\"),t._v(\"\\n原理：不设置ajax缓存\"),_(\"br\"),t._v(\" \"),_(\"a\",{attrs:{href:\"https://blog.csdn.net/qq_39561207/article/details/90487580\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"参考\"),_(\"OutboundLink\")],1)])]),t._v(\" \"),_(\"h2\",{attrs:{id:\"js-的节流和防抖\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-的节流和防抖\"}},[t._v(\"#\")]),t._v(\" JS 的节流和防抖\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}